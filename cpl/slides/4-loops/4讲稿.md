
1. Game of Life游戏
```C
//
// Created by 杨已彪 on 2024/10/18.
//
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

#define SIZE 6

const int board[SIZE][SIZE] = {
    {0},
    {0, 1, 1, 0, 0, 0},
    {0, 1, 1, 0, 0, 0},
    {0, 0, 0, 1, 1, 0},
    {0, 0, 0, 1, 1, 0},
    {0}
};

//const int board1[SIZE][SIZE] = {
//    [0] = {0},
//    [1] = {[1] = 1, [2] = 1},
//    [2] = {[1] = 1, [2] = 1},
//    [3] = {[3] = 1, [4] = 1},
//    [4] = {[3] = 1, [4] = 1}
//};
//
//const int board2[SIZE][SIZE] = {
//    [1][1] = 1, [1][2] = 1,
//    [2][1] = 1, [2][2] = 1,
//    [3][3] = 1, [3][4] = 1,
//    [4][3] = 1, [4][4] = 1
//};
//
//const int board3[SIZE][SIZE] = {
//    0, 0, 0, 0, 0, 0,
//    0, 1, 1, 0, 0, 0,
//    0, 1, 1, 0, 0, 0,
//    0, 0, 0, 1, 1, 0,
//    0, 0, 0, 1, 1, 0
//};

int main(void) {
  // TODO: play game-of-life
  // expand this board
  int old_board[SIZE + 2][SIZE + 2] = {0};
  int new_board[SIZE + 2][SIZE + 2] = {0};
  for (int i = 1; i <= SIZE; i++) {
    for (int j = 1; j <= SIZE; j++) {
      old_board[i][j] = board[i - 1][j - 1];
    }
  }

  // print the old board
  for (int i = 1; i <= SIZE; i++) {
    for (int j = 1; j <= SIZE; j++) {
      printf("%c ", old_board[i][j] ? '*' : ' ');
    }
    printf("\n");
  }
  system("clear");

  // Loop ten times
  for (int k = 0; k < 10; k++) {
    // count live neighbors for each cell
    for (int i = 1; i <= SIZE; i++) {
      for (int j = 1; j <= SIZE; j++) {
        int num_of_live_neighbors =
            old_board[i - 1][j - 1] + old_board[i - 1][j] + 
            old_board[i - 1][j + 1] + old_board[i][j - 1] + 
            old_board[i][j + 1] + old_board[i + 1][j - 1] + 
            old_board[i + 1][j] + old_board[i + 1][j + 1];
        if (old_board[i][j] == 1) {
          new_board[i][j] = num_of_live_neighbors == 2 || num_of_live_neighbors == 3;
        } else {
          new_board[i][j] = num_of_live_neighbors == 3;
        }
      }
    }

    // print the new board
    for (int i = 1; i <= SIZE; i++) {
      for (int j = 1; j <= SIZE; j++) {
        printf("%c ", new_board[i][j] ? '*' : ' ');
      }
      printf("\n");
    }

    sleep(1);
    system("clear");

    // copy new board onto old board
    for (int i = 1; i <= SIZE; i++) {
      for (int j = 1; j <= SIZE; j++) {
        old_board[i][j] = new_board[i][j];
        new_board[i][j] = 0;
      }
    }
  }

  return 0;
}
```
- 如何处理边界？（拓展数组+外部一圈）
- 如何去掉不必要的if 判断（8个邻居）
- 更新、某一时刻周边的邻居的状态（在新的数组上更新状态）
- 变量重名，scope不一样，内部的覆盖
- 演示清屏的效果


2. 归并排序 
```C
// Created by 杨已彪 on 2024/10/18.
#include <stdio.h>

#define LEN_L 5
#define LEN_R 6
int L[LEN_L] = {1, 3, 5, 7, 9};
int R[LEN_R] = {0, 2, 4, 6, 8, 10};

int main(void) {
  // TODO: merge L and R into a sorted array
  int l = 0;
  int r = 0;

  while (l < LEN_L && r < LEN_R) {
    if (L[l] < R[r]) {
      printf("%d ", L[l]);
      l++;
    } else {
      printf("%d ", R[r]);
      r++;
    }
  }

  while (r < LEN_R) {
    printf("%d ", R[r]);
    r++;
  }

  while (l < LEN_L) {
    printf("%d ", L[l]);
    l++;
  }

  return 0;
}
```
- 一开始使用if else 逐步去掉


3. 插入排序
```C
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#define MAX_LEN 10000
#define RANGE 20

int main(void) {
  int numbers[MAX_LEN] = {0};
  int size = 0;
  scanf("%d", &size);

  srand(time(NULL));
  for (int i = 0; i < size; i++) {
    numbers[i] = rand() % RANGE;
  }

  for (int i = 0; i < size; i++) {
    printf("%d ", numbers[i]);
  }
  printf("\n");

  // TODO: insertion sort
  for (int i = 1; i < size; i++) {
    int key = numbers[i];
    int j = i - 1;
    while (j >= 0 && numbers[j] > key) {
      numbers[j + 1] = numbers[j];
      j--;
    }
    numbers[j + 1] = key;

    // numbers[0 .. i] is already sorted
    for (int k = 0; k < size; k++) {
      printf("%d ", numbers[k]);
    }
    printf("\n");
  }

  // print the sorted array
  for (int k = 0; k < size; k++) {
    printf("%d ", numbers[k]);
  }
  printf("\n");

  return 0;
}
```
- [0..i - 1]已经有序
- 依次从最大的往前比


4. 插入排序（二分查找）
